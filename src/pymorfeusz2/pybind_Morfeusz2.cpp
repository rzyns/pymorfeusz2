#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

#include <morfeusz2.h>  // Change this include to the library you are binding

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

namespace morfeusz {
// helper type to enable overriding virtual methods in python
class Morfeusz_trampoline : public Morfeusz
{
public:
    using Morfeusz::Morfeusz;

    std::string getDictID() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            std::string, // return type
            morfeusz::Morfeusz, // parent class
            "get_dict_id", // function name (python)
            getDictID // function name (c++)
        );
    }
    std::string getDictCopyright() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            std::string, // return type
            morfeusz::Morfeusz, // parent class
            "get_dict_copyright", // function name (python)
            getDictCopyright // function name (c++)
        );
    }
    morfeusz::Morfeusz * clone() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::Morfeusz *, // return type
            morfeusz::Morfeusz, // parent class
            "clone", // function name (python)
            clone // function name (c++)
        );
    }
    morfeusz::ResultsIterator * analyse(const std::string & text) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::ResultsIterator *, // return type
            morfeusz::Morfeusz, // parent class
            "analyse", // function name (python)
            analyse, // function name (c++)
            text // params
        );
    }
    morfeusz::ResultsIterator * analyse(const char * text) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::ResultsIterator *, // return type
            morfeusz::Morfeusz, // parent class
            "analyse", // function name (python)
            analyse, // function name (c++)
            text // params
        );
    }
    void analyse(const std::string & text, std::vector<morfeusz::MorphInterpretation> & result) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "analyse", // function name (python)
            analyse, // function name (c++)
            text, result // params
        );
    }
    void generate(const std::string & lemma, std::vector<morfeusz::MorphInterpretation> & result) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "generate", // function name (python)
            generate, // function name (c++)
            lemma, result // params
        );
    }
    void generate(const std::string & lemma, int tagId, std::vector<morfeusz::MorphInterpretation> & result) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "generate", // function name (python)
            generate, // function name (c++)
            lemma, tagId, result // params
        );
    }
    void setCharset(morfeusz::Charset encoding) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_charset", // function name (python)
            setCharset, // function name (c++)
            encoding // params
        );
    }
    morfeusz::Charset getCharset() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::Charset, // return type
            morfeusz::Morfeusz, // parent class
            "get_charset", // function name (python)
            getCharset // function name (c++)
        );
    }
    void setAggl(const std::string & aggl) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_aggl", // function name (python)
            setAggl, // function name (c++)
            aggl // params
        );
    }
    std::string getAggl() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            std::string, // return type
            morfeusz::Morfeusz, // parent class
            "get_aggl", // function name (python)
            getAggl // function name (c++)
        );
    }
    void setPraet(const std::string & praet) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_praet", // function name (python)
            setPraet, // function name (c++)
            praet // params
        );
    }
    std::string getPraet() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            std::string, // return type
            morfeusz::Morfeusz, // parent class
            "get_praet", // function name (python)
            getPraet // function name (c++)
        );
    }
    void setCaseHandling(morfeusz::CaseHandling caseHandling) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_case_handling", // function name (python)
            setCaseHandling, // function name (c++)
            caseHandling // params
        );
    }
    morfeusz::CaseHandling getCaseHandling() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::CaseHandling, // return type
            morfeusz::Morfeusz, // parent class
            "get_case_handling", // function name (python)
            getCaseHandling // function name (c++)
        );
    }
    void setTokenNumbering(morfeusz::TokenNumbering numbering) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_token_numbering", // function name (python)
            setTokenNumbering, // function name (c++)
            numbering // params
        );
    }
    morfeusz::TokenNumbering getTokenNumbering() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::TokenNumbering, // return type
            morfeusz::Morfeusz, // parent class
            "get_token_numbering", // function name (python)
            getTokenNumbering // function name (c++)
        );
    }
    void setWhitespaceHandling(morfeusz::WhitespaceHandling whitespaceHandling) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_whitespace_handling", // function name (python)
            setWhitespaceHandling, // function name (c++)
            whitespaceHandling // params
        );
    }
    morfeusz::WhitespaceHandling getWhitespaceHandling() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::WhitespaceHandling, // return type
            morfeusz::Morfeusz, // parent class
            "get_whitespace_handling", // function name (python)
            getWhitespaceHandling // function name (c++)
        );
    }
    void setDebug(bool debug) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_debug", // function name (python)
            setDebug, // function name (c++)
            debug // params
        );
    }
    const morfeusz::IdResolver & getIdResolver() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const morfeusz::IdResolver &, // return type
            morfeusz::Morfeusz, // parent class
            "get_id_resolver", // function name (python)
            getIdResolver // function name (c++)
        );
    }
    void setDictionary(const std::string & dictName) override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            void, // return type
            morfeusz::Morfeusz, // parent class
            "set_dictionary", // function name (python)
            setDictionary, // function name (c++)
            dictName // params
        );
    }
    const std::set<std::string> & getAvailableAgglOptions() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::set<std::string> &, // return type
            morfeusz::Morfeusz, // parent class
            "get_available_aggl_options", // function name (python)
            getAvailableAgglOptions // function name (c++)
        );
    }
    const std::set<std::string> & getAvailablePraetOptions() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::set<std::string> &, // return type
            morfeusz::Morfeusz, // parent class
            "get_available_praet_options", // function name (python)
            getAvailablePraetOptions // function name (c++)
        );
    }
    morfeusz::ResultsIterator * analyseWithCopy(const char * text) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::ResultsIterator *, // return type
            morfeusz::Morfeusz, // parent class
            "analyse_with_copy", // function name (python)
            analyseWithCopy, // function name (c++)
            text // params
        );
    }
};
}  // namespace morfeusz

namespace morfeusz {
// helper type to enable overriding virtual methods in python
class ResultsIterator_trampoline : public ResultsIterator
{
public:
    using ResultsIterator::ResultsIterator;

    bool hasNext() override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            bool, // return type
            morfeusz::ResultsIterator, // parent class
            "has_next", // function name (python)
            hasNext // function name (c++)
        );
    }
    const morfeusz::MorphInterpretation & peek() override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const morfeusz::MorphInterpretation &, // return type
            morfeusz::ResultsIterator, // parent class
            "peek", // function name (python)
            peek // function name (c++)
        );
    }
    morfeusz::MorphInterpretation next() override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            morfeusz::MorphInterpretation, // return type
            morfeusz::ResultsIterator, // parent class
            "next", // function name (python)
            next // function name (c++)
        );
    }
};
}  // namespace morfeusz

namespace morfeusz {
// helper type to enable overriding virtual methods in python
class IdResolver_trampoline : public IdResolver
{
public:
    using IdResolver::IdResolver;

    const std::string getTagsetId() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::string, // return type
            morfeusz::IdResolver, // parent class
            "get_tagset_id", // function name (python)
            getTagsetId // function name (c++)
        );
    }
    const std::string & getTag(const int tagId) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::string &, // return type
            morfeusz::IdResolver, // parent class
            "get_tag", // function name (python)
            getTag, // function name (c++)
            tagId // params
        );
    }
    int getTagId(const std::string & tag) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            int, // return type
            morfeusz::IdResolver, // parent class
            "get_tag_id", // function name (python)
            getTagId, // function name (c++)
            tag // params
        );
    }
    const std::string & getName(const int nameId) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::string &, // return type
            morfeusz::IdResolver, // parent class
            "get_name", // function name (python)
            getName, // function name (c++)
            nameId // params
        );
    }
    int getNameId(const std::string & name) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            int, // return type
            morfeusz::IdResolver, // parent class
            "get_name_id", // function name (python)
            getNameId, // function name (c++)
            name // params
        );
    }
    const std::string & getLabelsAsString(int labelsId) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::string &, // return type
            morfeusz::IdResolver, // parent class
            "get_labels_as_string", // function name (python)
            getLabelsAsString, // function name (c++)
            labelsId // params
        );
    }
    const std::set<std::string> & getLabels(int labelsId) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            const std::set<std::string> &, // return type
            morfeusz::IdResolver, // parent class
            "get_labels", // function name (python)
            getLabels, // function name (c++)
            labelsId // params
        );
    }
    int getLabelsId(const std::string & labelsStr) const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            int, // return type
            morfeusz::IdResolver, // parent class
            "get_labels_id", // function name (python)
            getLabelsId, // function name (c++)
            labelsStr // params
        );
    }
    size_t getTagsCount() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            size_t, // return type
            morfeusz::IdResolver, // parent class
            "get_tags_count", // function name (python)
            getTagsCount // function name (c++)
        );
    }
    size_t getNamesCount() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            size_t, // return type
            morfeusz::IdResolver, // parent class
            "get_names_count", // function name (python)
            getNamesCount // function name (c++)
        );
    }
    size_t getLabelsCount() const override
    {
        PYBIND11_OVERRIDE_PURE_NAME(
            size_t, // return type
            morfeusz::IdResolver, // parent class
            "get_labels_count", // function name (python)
            getLabelsCount // function name (c++)
        );
    }
};
}  // namespace morfeusz

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


// You can add any code here


void py_init_module_morfeusz2(py::module& m)      //  rename this function name!!!
{
    // You can add any code here


    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:morfeusz2.h>    ////////////////////
    // #ifndef MORFEUSZ2_H
    //


    py::enum_<morfeusz::Charset>(m, "Charset", py::arithmetic(), "")
        .value("utf8", morfeusz::UTF8, "")
        .value("iso8859_2", morfeusz::ISO8859_2, "")
        .value("cp1250", morfeusz::CP1250, "")
        .value("cp852", morfeusz::CP852, "");


    py::enum_<morfeusz::TokenNumbering>(m, "TokenNumbering", py::arithmetic(), "")
        .value("separate_numbering", morfeusz::SEPARATE_NUMBERING, "*\n         * Start from 0. Reset counter for every invocation of Morfeusz::analyze (this is default)\n")
        .value("continuous_numbering", morfeusz::CONTINUOUS_NUMBERING, "*\n         * Also start from 0. Reset counter for every invocation of Morfeusz::setTokenNumbering only\n");


    py::enum_<morfeusz::CaseHandling>(m, "CaseHandling", py::arithmetic(), "")
        .value("conditionally_case_sensitive", morfeusz::CONDITIONALLY_CASE_SENSITIVE, "*\n         * Case-sensitive but allows interpretations that do not match case but there are no alternatives (this is default)\n")
        .value("strictly_case_sensitive", morfeusz::STRICTLY_CASE_SENSITIVE, "*\n         * Strictly case-sensitive, reject all interpretations that do not match case\n")
        .value("ignore_case", morfeusz::IGNORE_CASE, "*\n         * Case-insensitive - ignores case\n");


    py::enum_<morfeusz::WhitespaceHandling>(m, "WhitespaceHandling", py::arithmetic(), "")
        .value("skip_whitespaces", morfeusz::SKIP_WHITESPACES, "*\n         * Ignore whitespaces (this is default)\n")
        .value("append_whitespaces", morfeusz::APPEND_WHITESPACES, "*\n         * Append whitespaces to previous MorphInterpretation\n")
        .value("keep_whitespaces", morfeusz::KEEP_WHITESPACES, "*\n         * Whitespaces are separate MorphInterpretation objects\n");


    py::enum_<morfeusz::MorfeuszUsage>(m, "MorfeuszUsage", py::arithmetic(), "")
        .value("analyse_only", morfeusz::ANALYSE_ONLY, "")
        .value("generate_only", morfeusz::GENERATE_ONLY, "")
        .value("both_analyse_and_generate", morfeusz::BOTH_ANALYSE_AND_GENERATE, "");


    auto pyClassMorfeusz =
        py::class_<morfeusz::Morfeusz, morfeusz::Morfeusz_trampoline>
            (m, "Morfeusz", "*\n     * Performs morphological analysis (analyze methods) and syntesis (generate methods).\n     *\n     * It is NOT thread-safe\n     * but it is possible to use separate Morfeusz instance for each concurrent thread.\n")
        .def(py::init<>()) // implicit default constructor
        .def_static("get_version",
            &morfeusz::Morfeusz::getVersion, "*\n         * Returns a string containing library version.\n         * @return\n")
        .def_static("get_default_dict_name",
            &morfeusz::Morfeusz::getDefaultDictName, "*\n         * Returns a string containing default dictionary name.\n         * @return\n")
        .def_static("get_copyright",
            &morfeusz::Morfeusz::getCopyright, "*\n         * Returns morfeusz2 library copyright text.\n         * @return\n")
        .def_static("create_instance",
            py::overload_cast<morfeusz::MorfeuszUsage>(&morfeusz::Morfeusz::createInstance),
            py::arg("usage") = morfeusz::BOTH_ANALYSE_AND_GENERATE,
            "*\n         * Creates actual instance of Morfeusz class.\n         * The caller is responsible for destroying it.\n         *\n         * @remarks NOT THREAD-SAFE (affects ALL Morfeusz instances)\n         * @return new instance of Morfeusz.\n")
        .def_static("create_instance",
            py::overload_cast<const std::string &, morfeusz::MorfeuszUsage>(&morfeusz::Morfeusz::createInstance),
            py::arg("dict_name"), py::arg("usage") = morfeusz::BOTH_ANALYSE_AND_GENERATE,
            "*\n         * Creates actual instance of Morfeusz class with possibly non-default dictionary.\n         * The caller is responsible for destroying it.\n         *\n         * @remarks NOT THREAD-SAFE (affects ALL Morfeusz instances)\n         * @return new instance of Morfeusz.\n")
        .def("get_dict_id",
            &morfeusz::Morfeusz::getDictID, "*\n         * Returns current dictionary ID.\n         *\n         * @return dictionary ID string\n")
        .def("get_dict_copyright",
            &morfeusz::Morfeusz::getDictCopyright, "*\n         * Returns current dictionary copyright string.\n         *\n         * @return dictionary copyright string\n")
        .def("clone",
            &morfeusz::Morfeusz::clone, "*\n         * Creates exact copy of Morfeusz object.\n         *\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("analyse",
            py::overload_cast<const std::string &>(&morfeusz::Morfeusz::analyse, py::const_),
            py::arg("text"),
            "*\n         * Analyze given text and return the results as iterator.\n         * Use this method for analysis of big texts.\n         * Copies the text under the hood - use analyze(const char*) if you want to avoid this.\n         *\n         * @param text - text for morphological analysis.\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @return - iterator over morphological analysis results\n")
        .def("analyse",
            py::overload_cast<const char *>(&morfeusz::Morfeusz::analyse, py::const_),
            py::arg("text"),
            "*\n         * Analyze given text and return the results as iterator.\n         * It does not store results for whole text at once, so may be less memory-consuming for analysis of big texts\n         *\n         *\n         * @param text - text for morphological analysis. This pointer must not be deleted before returned ResultsIterator object.\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @return - iterator over morphological analysis results\n")
        .def("analyse",
            py::overload_cast<const std::string &, std::vector<morfeusz::MorphInterpretation> &>(&morfeusz::Morfeusz::analyse, py::const_),
            py::arg("text"), py::arg("result"),
            "*\n         * Perform morphological analysis on a given text and put results in a vector.\n         *\n         * @param text - text to be analyzed\n         * @param result - results vector\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("generate",
            py::overload_cast<const std::string &, std::vector<morfeusz::MorphInterpretation> &>(&morfeusz::Morfeusz::generate, py::const_),
            py::arg("lemma"), py::arg("result"),
            "*\n         * Perform morphological synthesis on a given lemma and put results in a vector.\n         *\n         * @param lemma - lemma to be analyzed\n         * @param result - results vector\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @throws MorfeuszException - when lemma parameter contains whitespaces.\n")
        .def("generate",
            py::overload_cast<const std::string &, int, std::vector<morfeusz::MorphInterpretation> &>(&morfeusz::Morfeusz::generate, py::const_),
            py::arg("lemma"), py::arg("tag_id"), py::arg("result"),
            "*\n         * Perform morphological synthesis on a given lemma and put results in a vector.\n         * Limit results to interpretations with the specified tag.\n         *\n         * @param lemma - lemma to be analyzed\n         * @param tag - tag of result interpretations\n         * @param result - results vector\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @throws MorfeuszException - when lemma parameter contains whitespaces or tagId is outside tagset.\n")
        .def("set_charset",
            &morfeusz::Morfeusz::setCharset,
            py::arg("encoding"),
            "*\n         * Set encoding for input and output string objects.\n         *\n         * @param encoding\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("get_charset",
            &morfeusz::Morfeusz::getCharset, "*\n         * Get charset used for input and output string objects.\n         * @return\n")
        .def("set_aggl",
            &morfeusz::Morfeusz::setAggl,
            py::arg("aggl"),
            "*\n         * Select agglutination rules.\n         *\n         * @param aggl\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @throws MorfeuszException - for invalid aggl parameter.\n")
        .def("get_aggl",
            &morfeusz::Morfeusz::getAggl, "*\n         * Get current agglutination rules option\n         * @return\n")
        .def("set_praet",
            &morfeusz::Morfeusz::setPraet,
            py::arg("praet"),
            "*\n         * Select past tense segmentation\n         *\n         * @param praet\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n         * @throws MorfeuszException - for invalid aggl praet parameter.\n")
        .def("get_praet",
            &morfeusz::Morfeusz::getPraet, "*\n         * Get current past tense segmentation option\n         * @return\n")
        .def("set_case_handling",
            &morfeusz::Morfeusz::setCaseHandling,
            py::arg("case_handling"),
            "*\n         * Set case handling.\n         *\n         * @param caseSensitive\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("get_case_handling",
            &morfeusz::Morfeusz::getCaseHandling, "*\n         * Get case handling policy.\n         * @return\n")
        .def("set_token_numbering",
            &morfeusz::Morfeusz::setTokenNumbering,
            py::arg("numbering"),
            "*\n         * Set token numbering policy.\n         *\n         * @param numbering\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("get_token_numbering",
            &morfeusz::Morfeusz::getTokenNumbering, "*\n         * Get token numbering policy.\n         * @return\n")
        .def("set_whitespace_handling",
            &morfeusz::Morfeusz::setWhitespaceHandling,
            py::arg("whitespace_handling"),
            "*\n         * Set whitespace handling.\n         *\n         * @param numbering\n         * @remarks NOT THREAD-SAFE (must have exclusive access to this instance. Does not affect other Morfeusz instances).\n")
        .def("get_whitespace_handling",
            &morfeusz::Morfeusz::getWhitespaceHandling, "*\n         * Get whitespace handling.\n         * @return\n")
        .def("set_debug",
            &morfeusz::Morfeusz::setDebug,
            py::arg("debug"),
            "*\n         * Set debug option value.\n         *\n         * @param debug\n")
        .def("get_id_resolver",
            &morfeusz::Morfeusz::getIdResolver, "*\n         * Get reference to tagset currently being in use.\n         *\n         * @return currently used tagset\n")
        .def("set_dictionary",
            &morfeusz::Morfeusz::setDictionary,
            py::arg("dict_name"),
            "*\n         * Set current dictionary to the one with provided name.\n         *\n         * This is NOT THREAD SAFE - no other thread may invoke setDictionary\n         * either within this instance, or any other in the same application.\n         *\n         * @param dictName dictionary name\n         * @remarks NOT THREAD-SAFE (affects ALL Morfeusz instances)\n         * @throws MorfeuszException - when dictionary not found.\n         * @throws std::ios_base::failure - when IO error occurred when loading given dictionary.\n")
        .def_readwrite_static("dictionary_search_paths", &morfeusz::Morfeusz::dictionarySearchPaths, "*\n         * List of paths where current Morfeusz instance will look for dictionaries.\n         * Modifying it is NOT THREAD-SAFE.\n")
        .def("get_available_aggl_options",
            &morfeusz::Morfeusz::getAvailableAgglOptions, "*\n         * Get available parameters for \"setAggl\" method.\n         * @return\n")
        .def("get_available_praet_options",
            &morfeusz::Morfeusz::getAvailablePraetOptions, "*\n         * Get available parameters for \"setPraet\" method.\n         * @return\n")
        ;


    auto pyClassResultsIterator =
        py::class_<morfeusz::ResultsIterator, morfeusz::ResultsIterator_trampoline>
            (m, "ResultsIterator", "")
        .def(py::init<>()) // implicit default constructor
        .def("has_next",
            &morfeusz::ResultsIterator::hasNext, "*\n         *\n         * @return True iff this iterator contains more elements.\n")
        .def("peek",
            &morfeusz::ResultsIterator::peek, "*\n         *\n         * @return the element, that will be returned in next next() invocation.\n         * @throws std::out_of_range when this iterator has already reached the end.\n")
        .def("next",
            &morfeusz::ResultsIterator::next, "*\n         *\n         * @return next analysis result.\n         * @throws std::out_of_range when this iterator has already reached the end.\n")
        ;


    auto pyClassIdResolver =
        py::class_<morfeusz::IdResolver, morfeusz::IdResolver_trampoline>
            (m, "IdResolver", "*\n     * Represents mappings for tags, names and labels.\n")
        .def(py::init<>()) // implicit default constructor
        .def("get_tagset_id",
            &morfeusz::IdResolver::getTagsetId, "*\n         * Returns current TAGSET-ID (as specified in first line of tagset file)\n         *\n         * @return tagset id string\n")
        .def("get_tag",
            &morfeusz::IdResolver::getTag,
            py::arg("tag_id"),
            "*\n         * Returns tag (denoted by its index).\n         *\n         * @param tagNum - tag index in the tagset.\n         * @return - the tag\n         * @throws std::out_of_range when invalid tagId is provided.\n")
        .def("get_tag_id",
            &morfeusz::IdResolver::getTagId,
            py::arg("tag"),
            "*\n         * Returns identifier for given tag.\n         * Throws MorfeuszException when none exists.\n         *\n         * @return identifier for given tag\n         * @throws MorfeuszException when invalid tag parameter is provided.\n")
        .def("get_name",
            &morfeusz::IdResolver::getName,
            py::arg("name_id"),
            "*\n         * Returns named entity type (denoted by its index).\n         *\n         * @param nameNum - name index in the tagset.\n         * @return - the named entity type\n         * @throws std::out_of_range when invalid nameId is provided.\n")
        .def("get_name_id",
            &morfeusz::IdResolver::getNameId,
            py::arg("name"),
            "*\n         * Returns identifier for given named entity.\n         * Throws MorfeuszException when none exists.\n         *\n         * @return identifier for given named entity\n         * @throws MorfeuszException when invalid name parameter is provided.\n")
        .def("get_labels_as_string",
            &morfeusz::IdResolver::getLabelsAsString,
            py::arg("labels_id"),
            "*\n         * Returns labels string for given labelsId.\n         *\n         * @param labelsId\n         * @return labels as string\n         * @throws std::out_of_range when invalid labelsId is provided.\n")
        .def("get_labels",
            &morfeusz::IdResolver::getLabels,
            py::arg("labels_id"),
            "*\n         * Returns labels as set of strings for given labelsId.\n         * @param labelsId\n         * @return labels as set of strings\n         * @throws std::out_of_range when invalid labelsId is provided.\n")
        .def("get_labels_id",
            &morfeusz::IdResolver::getLabelsId,
            py::arg("labels_str"),
            "*\n         * Get labelsId for given labels as string.\n         *\n         * @param labelsStr\n         * @return labelsId\n         * @throws MorfeuszException when invalid tag is provided.\n")
        .def("get_tags_count",
            &morfeusz::IdResolver::getTagsCount, "*\n         * Returns number of tags this tagset contains.\n         *\n         * @return\n")
        .def("get_names_count",
            &morfeusz::IdResolver::getNamesCount, "*\n         * Returns number of named entity types this tagset contains.\n         *\n         * @return\n")
        .def("get_labels_count",
            &morfeusz::IdResolver::getLabelsCount, "*\n         * Returns number of different labels combinations.\n")
        ;


    auto pyClassMorphInterpretation =
        py::class_<morfeusz::MorphInterpretation>
            (m, "MorphInterpretation", "*\n     The result of analysis is  a directed acyclic graph with numbered\n     nodes representing positions  in text (points _between_ segments)\n     and edges representing interpretations of segments that span from\n     one node to another.  E.g.,\n\n         {0,1,\"ja\",\"ja\",\"ppron12:sg:nom:m1.m2.m3..n1.n2:pri\"}\n         |\n         |      {1,2,\"został\",\"zostać\",\"praet:sg:m1.m2.m3:perf\"}\n         |      |\n       __|  ____|   __{2,3,\"em\",\"być\",\"aglt:sg:pri:imperf:wok\"}\n      /  \\ /     \\ / \\\n     * Ja * został*em *\n     0    1       2   3\n\n     Note that the word 'zostałem' got broken into 2 separate segments.\n     * One MorphInterpretation instance describes one edge of this DAG.\n")
        .def(py::init<>())
        .def_static("create_ign",
            &morfeusz::MorphInterpretation::createIgn,
            py::arg("start_node"), py::arg("end_node"), py::arg("orth"), py::arg("lemma"),
            "*\n         * Creates new instance with \"ign\" tag (meaning: \"not found in the dictionary\")\n")
        .def_static("create_whitespace",
            &morfeusz::MorphInterpretation::createWhitespace,
            py::arg("start_node"), py::arg("end_node"), py::arg("orth"),
            "*\n         * Creates new instance with \"sp\" tag (meaning: \"this is a sequence of whitespaces\")\n")
        .def("is_ign",
            &morfeusz::MorphInterpretation::isIgn, "*\n         *\n         * @return True iff this instance represents an unknown word.\n")
        .def("is_whitespace",
            &morfeusz::MorphInterpretation::isWhitespace, "*\n         *\n         * @return True iff this instance represents a whitespace.\n")
        .def("get_tag",
            &morfeusz::MorphInterpretation::getTag,
            py::arg("morfeusz"),
            "*\n         * Get tag as string.\n         *\n         * @param morfeusz Morfeusz instance this interpretation was created by.\n         * @return\n")
        .def("get_name",
            &morfeusz::MorphInterpretation::getName,
            py::arg("morfeusz"),
            "*\n         * Get name as string.\n         *\n         * @param morfeusz Morfeusz instance this interpretation was created by.\n         * @return\n")
        .def("get_labels_as_string",
            &morfeusz::MorphInterpretation::getLabelsAsString,
            py::arg("morfeusz"),
            "*\n         * Get labels as string.\n         *\n         * @param morfeusz Morfeusz instance this interpretation was created by.\n         * @return\n")
        .def("get_labels",
            &morfeusz::MorphInterpretation::getLabels,
            py::arg("morfeusz"),
            "*\n         * Get tag as set of strings.\n         *\n         * @param morfeusz Morfeusz instance this interpretation was created by.\n         * @return\n")
        .def_readwrite("start_node", &morfeusz::MorphInterpretation::startNode, "")
        .def_readwrite("end_node", &morfeusz::MorphInterpretation::endNode, "")
        .def_readwrite("orth", &morfeusz::MorphInterpretation::orth, "")
        .def_readwrite("lemma", &morfeusz::MorphInterpretation::lemma, "")
        .def_readwrite("tag_id", &morfeusz::MorphInterpretation::tagId, "")
        .def_readwrite("name_id", &morfeusz::MorphInterpretation::nameId, "")
        .def_readwrite("labels_id", &morfeusz::MorphInterpretation::labelsId, "")
        ;


    auto pyClassMorfeuszException =
        py::class_<morfeusz::MorfeuszException>
            (m, "MorfeuszException", "")
        .def(py::init<const std::string &>(),
            py::arg("what"))
        ;


    auto pyClassFileFormatException =
        py::class_<morfeusz::FileFormatException, morfeusz::MorfeuszException>
            (m, "FileFormatException", "")
        .def(py::init<const std::string &>(),
            py::arg("what"))
        ;
    // #endif
    ////////////////////    </generated_from:morfeusz2.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
